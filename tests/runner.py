#!/usr/bin/python



#*******************************************************************************************************************************
#*******************************************************************************************************************************
# This script is used to run both pastorius and Sander.
# The script generates all inputs needed to run pastorius from a set of files with similar structure to Amber input (mdin, top, rst ). 
# Hence, simulations can be executed using pastorius software with the same input as Amber(Sander), simplifying the use and comparison of results.
#  Script inputs:
#       -i *.mdin
#	-p *.prmtop
#	-c *.rst7
#
#   if these files are not specified the standard files are used (if found):
#		../Input/Amber/input.mdin  input.prmtop .rst7
#*******************************************************************************************************************************
#*******************************************************************************************************************************



#*******************************************************************************************************************************
#  This script creates the input files for Pastorius in the folder:  ../Input/Pastorius
#  files created:  
#	particles.in     --> Includes positions, velocities, 
#  	LennardCoeffs    --> Includes L-J coeffs  (the types present in the input particle system are copied from a full table)
#			****THE INPUT TO pastorius ARE epsilon and sigma (The input to Amber are A and B)
#*******************************************************************************************************************************




import operator
import os
from math import *
import sys
from os.path import isfile
from itertools import *
import numpy as np
import string
from datetime import datetime


#***********************************************************************
#************************** Global Variables ***************************
#***********************************************************************

endl = "\n"
tab = "\t"
make = False
time = False
coordinates = False
derivativeMode = False
analyticMode = False
periodicity = False
debug = False

currScnd= datetime.now().second
currMin = datetime.now().minute
currHour = datetime.now().hour


#************************
#Folders and files names:
#************************
today = "_"+str(currHour)+"_"+str(currMin)+"_"+str(currScnd)
defaultTopFile = "input.prmtop"
defaultRstFile = "input.rst7"
defaultMdinFile = "input.mdin"

bin_path =  "../bin/"
input_path =  "../Input/"
input_amber_path = "../Input/Amber/"
input_pastorius_path = "../Input/Pastorius/"   #DIRECTORY TO WRITE FILES TO (PASTORIUS INPUT)
output_sander_path = "../Output/Amber/"
output_pastorius_path = "../Output/Pastorius/"
lennardTableFilename = "FullCoeffsTable"  #*****READ ONLY**** THIS TABLE CONTAINS sigma, epsilon and mass for **ALL** type of particles
lennardOutFilename = "LennardCoeffs"  #This table(generated by this script) contains: sigma, epsilon and mass for existent types in the current simulation system. (this is one of the 2 input files for pastorius)
particlesFilename = "particles.in"               #THIS FILE CONTAINS ALL PARAMETERS NEEDED BY pastorius: number, type and coordinates of all part. + simulation parameters
outSanderFilename = "outSander"
output_pastorius_times_path = output_pastorius_path
output_sander_Times_path = output_sander_path
timesOutFilenameLow = "times"
timesOutFilenameHigh = ".out"
traceOutFilename = "trace"+today+".out"



#************************
#Top and Rst variables:
#************************

#TYPE is a dictionary. Each stored key is a type of particle (C, O, H, etc), and each is associated with a dictionary containing 3 keys: sigma, epsilon, mass  
TYPE = {}         





#######################################################################################
#######################################################################################
#THIS SET OF VARIABLES ARE USED TO LOAD ALL PARAMETERS FROM top FILE (Amber formatting)
#######################################################################################

NATOM = 0
NTYPES = 0

# FOR EACH PARTICLE TYPE DEFINED IN top
AMBER_ATOM_TYPE = []
CHARGE = []
ATOMIC_NUMBER = []
MASS = []
ACOEF = []
BCOEF = []
#########


#These arrays are used to store the sigma and epsilon values calculated from A and B coeffs.
sigma = []
epsilon = []
#######################################################################################





####################################################################
##### THESE VARIABLES ARE USED TO LOAD rst FILE DATA

#start time (if defined=simulation is a restart)
TIME_i = 0

#POSITION AND VELOCITY SAVE A DICTIONARY WITH KEYS(x,y,z) FOR EACH PARTICLE IN rst FILE
POSITION = []
VELOCITY = []

BOX = {}     #DICTIONARY WITH PARAMS LOADED FROM rst FILE. KEYS: x,y,z, alpha,beta,gamma















#************************
#Default Input Values:
#************************
imin = 0
ntb = 0
ntp=0
ntt = 1
nstlim =  999
dt = 0.001
vlimit = 1
ntf = 1
ibelly = 0
ntx = 5
irest = 1
ntpr = 1
ntwx = 1
ntwe = 1
temp0 =100.0
tempi = 0
tautp= 2.0
cut=12.0






#***********************************************************************
#****************************** Functions ******************************
#***********************************************************************



#****************************************************************
#This function loads all parameters(sigma, epsilon, mass) from a table to TYPE dictionary (see TYPE 'declaration' for structure info)
#*****************************************************************
def openLennardTable():
  global lennardTableFilename, TYPE

  print endl + "****************************************************"
  print "Parsing Lennard Table"
  print "****************************************************"

  if not isfile(input_path + lennardTableFilename):
    print "The file ", inpt_path + lennardTableFilename, " doesn't exist."
    exit()
  
  lennard = open(input_path + lennardTableFilename, 'r')
  for l in lennard:
    l = l.strip()
    if not l.split() or l.startswith('<end>'):
      #print l
      break
    if l.startswith('#') or l.startswith('<start>'):
      #print l
      continue
    f = l.split()
    TYPE[f[0]] = {'sigma': float(f[1]), 'epsilon': float(f[2]),\
     'charge': float(f[3])}            #####************************PARAMETER 3 IS THE MASSS!!!!!! NOT CHARGE!!!!
  
  lennard.close()

#***********************************************************************







#****************************************************************
#This function loads all parameters defined in top file (same formatting as Amber).
#*****************************************************************
def parseTop(_top):
  global NATOM, NTYPES, AMBER_ATOM_TYPE, CHARGE, \
  ATOMIC_NUMBER, MASS, ACOEF, BCOEF, particlesFilename

  print endl + "****************************************************"
  print "Parsing the top file"
  print "****************************************************"
  
  if not isfile(_top):
    print "The file ", _top, " doesn't exist."
    exit()
  
  topFile = open(_top, 'r')
  
  topFile_iter = iter(topFile)
  for t in topFile_iter:
    if t.startswith("%FLAG POINTERS"):
      f = topFile_iter.next()
      if f.startswith("%FORMAT(10I8)"):
	l = (topFile_iter.next()).split()
	NATOM = int(l[0])
	NTYPES = int(l[1])
	#Here we can get all necesary parameters
      else:
	print "error: The file", _top, " isnt a prmtop file"
      print "NATOM: ", NATOM
      print "NTYPES: ", NTYPES
    
    if t.startswith("%FLAG AMBER_ATOM_TYPE"):
      t = topFile_iter.next()
      if t.startswith("%FORMAT(20a4)"):
	t = topFile_iter.next()
	while not t.startswith("%"):
	  l = t.split()
	  for name in l:
	    AMBER_ATOM_TYPE.append(name)
	  t = topFile_iter.next()
      else:
	print "error: The file", _top, " isnt a prmtop file"
      #print "AMBER_ATOM_TYPE: ", AMBER_ATOM_TYPE
    
    if t.startswith("%FLAG CHARGE"):
      #print "CHARGE"
      t = topFile_iter.next()
      if t.startswith("%FORMAT(5E16.8)"):
	t = topFile_iter.next()
	while not t.startswith("%"):
	  l = t.split()
	  for ch in l:
	    CHARGE.append(float(ch))
	  t = topFile_iter.next()
      else:
	print "error: The file", _top, " isnt a prmtop file"
      #print "CHARGE: ", CHARGE
      #print "len(CHARGE): ",len(CHARGE)
    
    if t.startswith("%FLAG MASS"):
      t = topFile_iter.next()
      if t.startswith("%FORMAT(5E16.8)"):
	t = topFile_iter.next()
	while not t.startswith("%"):
	  l = t.split()
	  for m in l:
	    MASS.append(float(m))
	  t = topFile_iter.next()
      else:
	print "error: The file", _top, " isnt a prmtop file"
      #print "MASS: ", MASS
    
    
    
    
    # %FLAG LENNARD_JONES_ACOEF
    # %FORMAT(5E16.8)  (CN1(i), i=1,NTYPES*(NTYPES+1)/2)
    # CN1  : Lennard Jones r**12 terms for all possible atom type interactions,
    #       indexed by ICO and IAC; for atom i and j where i < j, the index into
    #       this array is as follows (assuming the value of ICO(index) is positive):
    #       CN1(ICO(NTYPES*(IAC(i)-1)+IAC(j))).
    
    if t.startswith("%FLAG LENNARD_JONES_ACOEF"):
      t = topFile_iter.next()
      if t.startswith("%FORMAT(5E16.8)"):
	t = (topFile_iter.next()).split()
	for acoef in t:
	  ACOEF.append(float(acoef))
      else:
	print "error: The file", _top, " isnt a prmtop file"
      print "ACOEF: ", ACOEF
      continue
    
    
    if t.startswith("%FLAG LENNARD_JONES_BCOEF"):
      t = topFile_iter.next()
      if t.startswith("%FORMAT(5E16.8)"):
	t = (topFile_iter.next()).split()
	for bcoef in t:
	  BCOEF.append(float(bcoef))
      else:
	print "error: The file", _top, " isnt a prmtop file"
      print "BCOEF: ", BCOEF
    
  
  #for debug
  for i in range(0, NTYPES*(NTYPES+1)/2):
    A = ACOEF[i]
    B = BCOEF[i]
    sigma.append((A/B)**(1.0/6))
    epsilon.append((B**2)/(4*A))
  print "sigma = " + str(sigma)
  print "epsilon = " + str(epsilon)
  
  topFile.close()

#***********************************************************************








#****************************************************************
#This function loads positions, velocities(in case these are defined) and box size. The values are read from rst file (same format as Ambers)
#*****************************************************************
def parseRst(_rst):
  global NATOM, NTYPES, AMBER_ATOM_TYPE, CHARGE, POSITION, \
  ATOMIC_NUMBER, MASS, ACOEF, BCOEF, particlesFilename, \
  VELOCITY, TIME_i, BOX, ntb

  print endl + "****************************************************"
  print "Parsing the rst file"
  print "****************************************************"
  
  if not isfile(_rst):
    print "The file ", _rst, " doesn't exist."
    exit()
  
  rstFile = open(_rst, 'r')
  
  l = rstFile.readline()
  l = rstFile.readline().split()
  print l
  if int(l[0]) != NATOM:
    print "ERROR: the file ", _rst, " doesn\'t match with the top file"
    exit()
  if len(l) > 1:
    TIME_i = float(l[1])
  
  #POSITIONS
  for i in range(0, NATOM/2):
    f = rstFile.readline().split()
    POSITION.append({'x': float(f[0]), 'y': float(f[1]), 'z': float(f[2])})
    POSITION.append({'x': float(f[3]), 'y': float(f[4]), 'z': float(f[5])})
  if NATOM/2 < NATOM/2.0:
    f = rstFile.readline.split()
    POSITION.append({'x': float(f[0]), 'y': float(f[1]), 'z': float(f[2])})
  
  #VELOCITIES
  if rstFile.tell() == os.fstat(rstFile.fileno()).st_size:
    print "There are not velocities in the rst file"
    print "There aren\'t Box parameters"
    exit()
  
  f = rstFile.readline().split()
  #if there is box
  if ntb != 0:     # PERIODIC BOUNDARIES
    periodicity = True
    if rstFile.tell() == os.fstat(rstFile.fileno()).st_size:
      print "There are not velocities in the rst file"
      #f --> box
      #FORMAT(6F12.7) BOX(1), BOX(2), BOX(3)
      #BOX    : size of the periodic box
      #print f
      BOX['x'] = float(f[0])
      BOX['y'] = float(f[1])
      BOX['z'] = float(f[2])
      BOX['alpha'] = float(f[3])
      BOX['beta'] = float(f[4])
      BOX['gamma'] = float(f[5])
      #print "POS:", POSITION
      #print "VEL:", VELOCITY
      #print "BOX:", BOX
      rstFile.close()
      return
    else:
      print "read particles velocities and box dimensions"
  else:
    print "only read velocities (not periodic)"
  
  for i in range(0, NATOM/2):
    VELOCITY.append({'x': float(f[0]), 'y': float(f[1]), 'z': float(f[2])})
    VELOCITY.append({'x': float(f[3]), 'y': float(f[4]), 'z': float(f[5])})
    if rstFile.tell() != os.fstat(rstFile.fileno()).st_size:
      f = rstFile.readline().split()
    else:
      rstFile.close()
      if(ntb != 0):
	print "ERROR There aren\'t Box parameters"
	exit()
      return
      
  if NATOM/2 < NATOM/2.0:
    VELOCITY.append({'x': float(f[0]), 'y': float(f[1]), 'z': float(f[2])})
    if rstFile.tell() != os.fstat(rstFile.fileno()).st_size:
      f = rstFile.readline().split()
    else:
      rstFile.close()
      if(ntb != 0):
	print "ERROR There aren\'t Box parameters"
	exit()
      return
    
  if f == []:
    rstFile.close()
    if(ntb != 0):
      print "ERROR There aren\'t Box parameters"
      exit()
    return
  #BOX
  #FORMAT(6F12.7) BOX(1), BOX(2), BOX(3)
  #BOX    : size of the periodic box
  BOX['x'] = float(f[0])
  BOX['y'] = float(f[1])
  BOX['z'] = float(f[2])
  BOX['alpha'] = float(f[3])
  BOX['beta'] = float(f[4])
  BOX['gamma'] = float(f[5])
  
  #print "POS:", POSITION
  #print "VEL:", VELOCITY
  #print "BOX:", BOX
  rstFile.close()

#***********************************************************************








#****************************************************************
#This function loads all variables defined in mdin file (Ambers mdin) into script variables.
#*****************************************************************
def parseMdin(_mdin):
  global NATOM, NTYPES, AMBER_ATOM_TYPE, CHARGE, POSITION, \
  ATOMIC_NUMBER, MASS, ACOEF, BCOEF, particlesFilename, \
  VELOCITY, TIME_i, imin, ntb, ntp, ntt, nstlim, dt, \
  vlimit, ntf, ibelly, ntx, irest, ntpr, ntwx, ntwe, \
  temp0, tempi, tautp, cut

  #print endl + "****************************************************"
  #print "Parsing the mdin file"
  #print "****************************************************"
  
  if not isfile(_mdin):
    print "The file ", _mdin, " doesn't exist."
    exit()
  
  mdinFile = open(_mdin, 'r')
  
  for l in mdinFile:
    if '&end' in l:
      break;
    noSpaces = l.replace(' ', '')
    parms = noSpaces.split(',')
    for parm in parms:
      setting = parm.split('=')
      for i in range(0,len(setting)):
	if setting[i] == 'temp0':
	  temp0 = float(setting[i+1])
	if setting[i] == 'tempi':
	  tempi = float(setting[i+1])
	if setting[i] == 'dt':
	  dt = float(setting[i+1])
	if setting[i] == 'nstlim':
	  nstlim = int(setting[i+1])
	if setting[i] == 'cut':
	  cut = float(setting[i+1])
	if setting[i] == 'ntb':
	  ntb = float(setting[i+1])
  
  print "dt = ", dt
  print "temp0 = ", temp0
  print "tautp = ", tautp
  print "nstlim = ", nstlim
  print "ntb = ", ntb
  print "cut = ", cut
  mdinFile.close()  

#***********************************************************************









#***********************************************************************************************************
# # This function creates a new mdin file with the number of steps recieved by parameter (all the other values are keeped)
#*************************************************************************************************************
def setStepsMdin(n,_mdin, _mdin_modified):
  #print endl + "****************************************************"
  #print "Modifying the mdin file to " + _mdin_modified
  #print "****************************************************"
  
  if not isfile(_mdin):
    print "The file ", _mdin, " doesn't exist."
    exit()
  
  mdinModFile = open(_mdin_modified, 'w')
  mdinFile = open(_mdin, 'r')
  
  newSTLIM = 'nstlim = '+str(n)+',\n'
  for l in mdinFile:
    if 'nstlim' in l:
      noSpaces = l.replace(' ', '')
      parms = noSpaces.split(',')
      ant = "  "
      for parm in parms:
	if 'nstlim' in parm:
	  ant += newSTLIM
	elif not '\n' in parm:
	  ant += parm + ','
      mdinModFile.write(ant)
    else:
      mdinModFile.write(l)
  mdinModFile.close()

#******************************************





#***********************************************************************
# This function creates a new mdin file with the cutoff value recieved (all the other values are keeped)
#***********************************************************************
def setCutMdin(cutOff,_mdin, _mdin_modified):
  #print endl + "****************************************************"
  #print "Modifying the mdin file to " + _mdin_modified
  #print "****************************************************"

  if not isfile(_mdin):
    print "The file ", _mdin, " doesn't exist."
    exit()

  mdinModFile = open(_mdin_modified, 'w')
  mdinFile = open(_mdin, 'r')

  newCUT = 'cut = '+str(cutOff)+',\n'
  for l in mdinFile:
    if 'cut' in l:
      noSpaces = l.replace(' ', '')
      parms = noSpaces.split(',')
      ant = "  "
      for parm in parms:
        if 'cut' in parm:
          ant += newCUT
        elif not '\n' in parm:
          ant += parm + ','
      mdinModFile.write(ant)
    else:
      mdinModFile.write(l)
  mdinModFile.close()


#***********************************************************************





#***********************************************************************
# This function creates the particles.in file (Input used by pastorius), from the set of values loaded.
def makeParticlesInputFile():
  global NATOM, NTYPES, AMBER_ATOM_TYPE, CHARGE, POSITION, VELOCITY,\
  ATOMIC_NUMBER, MASS, ACOEF, BCOEF, BOX, particlesFilename

  print endl + "****************************************************"
  print "Making the inputFile (particles.in)"
  print "****************************************************"

  particlesFile = open(input_pastorius_path + particlesFilename, 'w')
  
  #type, position, velocitie, charge
  particlesFile.write(str(NATOM)+endl)
  if(len(VELOCITY) > 0):
    for i in range(0, NATOM):
      particlesFile.write(AMBER_ATOM_TYPE[i] + tab + 
      str(POSITION[i]['x']) + tab + str(POSITION[i]['y']) + tab + str(POSITION[i]['z']) + tab +
      str(VELOCITY[i]['x']) + tab + str(VELOCITY[i]['y']) + tab + str(VELOCITY[i]['z']) + tab +
      str(CHARGE[i]) + endl)
  else:
    for i in range(0, NATOM):
      particlesFile.write(AMBER_ATOM_TYPE[i] + tab + 
      str(POSITION[i]['x']) + tab + str(POSITION[i]['y']) + tab + str(POSITION[i]['z']) + tab +
      str(0) + tab + str(0) + tab + str(0) + tab +
      str(CHARGE[i]) + endl)
    
  #box
  if ntb == 1:
    particlesFile.write(str(1) + tab)
    particlesFile.write(str(BOX['x']) + tab + str(BOX['y']) + tab + str(BOX['z']) + tab +
		        str(BOX['alpha']) + tab + str(BOX['beta']) + tab + str(BOX['gamma']) + endl )
  else:
    particlesFile.write(str(0) + endl)
    
  #parameters for run
  particlesFile.write(str(nstlim) + endl +
		      str(dt) + endl +
		      str(temp0) + endl +
		      str(tempi) + endl +
		      str(tautp) + endl +
		      str(cut) + endl)
  
  particlesFile.write( endl + "#Format:" + endl +
			"NATOM" + endl +
			"TYPE" + tab + "POS(x)" + tab + "POS(y)" + tab + "POS(z)" +
			tab + "VEL(x)" + tab + "VEL(y)" + tab + "VEL(z)"+
			tab + "CHARGE" + endl +
			"BOX?" + tab + "BOX(x)" + tab + "BOX(y)" + tab + "BOX(z)" + 
                        tab + "BOX(alpha)" + tab +  "BOX(beta)" + tab +  "BOX(gamma)" + endl + 
                        "NSTLIM" + endl +
			"dt" + endl +
			"temp0" + endl +
			"tempi" + endl +
			"tautp" + endl + 
			"cut" + endl)
  particlesFile.close()



#***********************************************************************






#***********************************************************************
#This function generates a table with the coeffs and mass of the the types used **ONLY**
def makeLennardTable():
  global NATOM, NTYPES, AMBER_ATOM_TYPE, CHARGE, TYPE, \
  ATOMIC_NUMBER, MASS, ACOEF, BCOEF, lennardOutFilename, \
  lennardInputFilename

  print endl + "****************************************************"
  print "Making the lennardTable (LennardCoeffs)"
  print "****************************************************"

  lennard = open(input_pastorius_path + lennardOutFilename, 'w')
  
  used_types = set(AMBER_ATOM_TYPE)
  
  lennard.write(str(NTYPES) + endl)
  for t in used_types:
    lennard.write(t + tab + 
		  str(TYPE[t]['sigma']) + tab + 
		  str(TYPE[t]['epsilon']) + tab + 
		  str(TYPE[t]['charge']) + endl)
  lennard.close()

#***********************************************************************








#***********************************************************************
# Run pastorius
def runMacheAmber():
  global make, time, derivativeMode, analyticMode, ntb, coordinates, \
         output_pastorius_times_path, output_sander_Times_path, \
         timesOutFilenameLow, timesOutFilenameHigh, debug
  
  #***********************************************
  ####EDIT!!!!   Makefile is in parent directory
  #if make:
    #makeCommand = "make"
    #print makeCommand
    #os.system(makeCommand)
    
    
    
  runCommand = bin_path + "pastorius"
  
  
  if ntb==1:
    runCommand += " -p "
  if analyticMode:
    runCommand += " -a "
  if derivativeMode:
    runCommand += " -d "
  if coordinates:
    runCommand += " -c "
  if time:
    runCommand += " -t " + output_pastorius_times_path + timesOutFilenameLow + timesOutFilenameHigh
  else:
    if debug:
      runCommand += " -r "
    else:
      runCommand += " -ar "
  print runCommand
  os.system(runCommand)
  
  make = False

#***********************************************************************










#***********************************************************************
# Run Amber (Sander version)
def runSander(_top, _rst, _mdin, gpu):
  global time, nstlim, output_sander_Times_path, \
         output_sander_path, \
         timesOutFilenameLow, timesOutFilenameHigh
  
  if not os.path.exists(output_sander_path):
    os.makedirs(output_sander_path)
  else:
    for file in os.listdir(output_sander_path):
      if file.endswith("mdcrd") or file.endswith("mdinfo") or \
         file.endswith("mden") or file.endswith("restrt") or \
         file.endswith(outSanderFilename):
              os.system("rm " + output_sander_path + "/" + file)
  if gpu:
      runCommand = "pmemd.cuda_SPFP -O"
  else:
      runCommand = "sander -O"
      
  if time:
    if gpu:
      timesSanderFilename = output_sander_Times_path + timesOutFilenameLow + "_gpu_" + timesOutFilenameHigh
    else:
      timesSanderFilename = output_sander_Times_path + timesOutFilenameLow + timesOutFilenameHigh
    if not os.path.exists(output_sander_Times_path):
	os.makedirs(output_sander_Times_path)	

  runCommand += " -i " + _mdin
  runCommand += " -o " + outSanderFilename
  runCommand += " -p " + _top 
  runCommand += " -c " + _rst
  
  print runCommand
  os.system(runCommand)
  
  if gpu:
    output_sander_path_mov = output_sander_path + "Parallel/"
  else:
    output_sander_path_mov = output_sander_path + "Secuential/"
  
  if not os.path.exists(output_sander_path_mov):
	os.makedirs(output_sander_path_mov)
  
  moveCommand = "mv "
  for file in os.listdir("."):
    if file.endswith("mdcrd") or file.endswith("mdinfo") or \
      file.endswith("mden") or file.endswith("restrt") or \
      file.endswith(outSanderFilename):
	      os.system(moveCommand + file + " " + output_sander_path_mov)
  
  if time:
	print "Times in sander"
	with open(output_sander_path_mov + outSanderFilename, 'r') as outSander:
	    with open(timesSanderFilename, 'a+') as timesSander:
	      for l in outSander:
		  if "Elapsed(s)" in l:
		      l = l.replace('|', '').strip()
		      timesSander.write(str(nstlim)+ tab+ str(l.split()[2]))
		      timesSander.write(endl)

#***********************************************************************







def printHelp():
  print endl + "The usage mode is: "
  print "  python runner.py [options]"
  print endl + "   where options are:"
  print tab + "-P or -p :" + tab + "TopFile"
  print tab + "-C or -c :" + tab + "RstFile"
  print tab + "-I or -i :" + tab + "inputFile"
  print tab + "-T or -t :" + tab + "cantSteps   amountOfSamples   [-log]" 



  













#***********************************************************************
#**************************** Main Program *****************************
#***********************************************************************



#DEFAULT INPUT
top = input_amber_path + defaultTopFile
rst = input_amber_path + defaultRstFile
mdin = input_amber_path + defaultMdinFile






if len(sys.argv) < 2:
  print "\n Using all the default input files:"
  print tab + top
  print tab + rst
  print tab + mdin
  print "\n If you want a specific input file, see the help running:"
  print tab + "python running.py -h"
else:
  
  #***********************************************************************
  #       PROCESS PARAMETERS
  #***********************************************************************

  
  for i in range(1,len(sys.argv)):
    arg = sys.argv[i]
    
    if (arg=='-H' or arg== '-h' or arg== '-help' or arg== '--help'):
      printHelp()
      exit()
    elif (arg=='-T' or arg== '-t'):
      steps = int(sys.argv[i+1])
      samples = int(sys.argv[i+2])
      time = True
      if (i < (len(sys.argv)-3)):
	if (sys.argv[i+3]=='-log'):
	  log = True
      else:
	log = False
    elif (arg=='-P' or arg== '-p') and (i < len(sys.argv)):
      top = sys.argv[i+1]
    elif (arg=='-C' or arg== '-c') and (i < len(sys.argv)):
      rst = sys.argv[i+1]
    elif (arg=='-I' or arg== '-i') and (i < len(sys.argv)):
      mdin = sys.argv[i+1]
    elif (arg=='-D' or arg== '-d'):
      debug = True
  print "\n Using the input files:"
  print tab + top
  print tab + rst
  print tab + mdin




#LOAD COEFFS AND MASS VALUES FROM TABLE (WHY NOT DIRECTLY FROM topFile????)
openLennardTable()

#LOAD PARAMETERS FROM (AMBER-STYLE) FILES
parseTop(top)
parseMdin(mdin)
parseRst(rst)

#CREATE COEFFS INPUT FILE FOR pastorius
makeLennardTable()

if not time:
  analyticMode = False
  derivativeMode = False
  coordinates = True
  time = False
  makeParticlesInputFile()    #CREATE INPUT FILE FOR pastorius
  #runMacheAmber()
  gpu = False
  #runSander(top, rst, mdin, gpu)
  gpu = True
  #runSander(top, rst, mdin, gpu)
  
else:
  print endl + "****************************************************"
  print "Running time by steps"
  print "****************************************************"
  print " Results in the file  " + output_pastorius_path+traceOutFilename + endl
  
  #create directory to 
  directory = str(steps) +"_"+ str(samples)+"/"
  if not os.path.exists(output_pastorius_path+directory):
    os.makedirs(output_pastorius_path+directory)
  output_pastorius_times_path = output_pastorius_path + directory
  output_sander_Times_path = output_sander_path + directory
  #****Redirect stdout to a file****
  #sys.stdout = open(output_pastorius_path+directory+traceOutFilename, 'w')
  
  #CREATE DIRECTORY TO SAVE AMBER INPUT FILES(Modifying mdin) 
  if not os.path.exists(input_amber_path):
    os.makedirs(input_amber_path)  
  
  n=100
  #mdin_modified = mdin + "_" + str(n)
  
  #EDIT MDIN TO IDENTIFY NUMBER OF STEPS
  mdin_modified = input_amber_path +  "input_n" + str(n) +  ".mdin"   
  #*************CHANGE NAME IF ITERATING OVER CUTOFF OR SOMETHING
  
  ##SHOULD I COPY THE rst AND top FILES IN THE input_amber_path ???? JUST TO KEEP IT ALL TOGETHER
  
  
  for cutoffVar in range (0,8,2):
      setStepsMdin(n, mdin, mdin_modified)    #SET NUMBER OF STEPS CORRESPONDING TO THIS ITERATION
      setCutMdin(cutoffVar, mdin, mdin_modified)  #SET CUTFF CORRESPONDING TO THIS ITERATION
      parseMdin(mdin_modified)    #LOAD THE MODIFIED VERSION OF mdin
      makeParticlesInputFile()    #CREATE INPUT FILE FOR pastorius
      cut=cutoffVar
      print "steps:" + str(n)
      print "cut:" + str(cut)       
	
	
	
      #**********************************
      #RUN DIFFERENT VERSIONS
      #**********************************
      #periodicity=True 
      analyticMode = False
      derivativeMode = False
      timesOutFilenameHigh = ".out"
      runMacheAmber()
      gpu = False
      #runSander(top, rst, mdin_modified, gpu)
      gpu = True
      #runSander(top, rst, mdin_modified, gpu)
      
      
      analyticMode = True
      derivativeMode = False
      timesOutFilenameHigh = "_a.out"
      #runMacheAmber()
      
      
      analyticMode = False
      derivativeMode = True
      timesOutFilenameHigh = "_d.out"
      #runMacheAmber()
      
      os.remove(mdin_modified)    #REMOVE LAST ITERATIONs mdin (JUST TO CLEAN IT UP)
      print "------------------------------------------"		
	
	
